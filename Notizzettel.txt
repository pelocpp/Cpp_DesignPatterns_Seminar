===============================

Seminar "C++ Design Pattern"

Peter Loos // Du

30+ Jahre:

i) Entwicklung
ii) Schulung / Training

== C/C++, Java, C#, Mobile Programming, JavaScript, (Python)

Back to the Roots: C++

Guten Morgen

===============================

a) Visual Studio 2022 (Community - for free)

b) Github:

https://github.com/pelocpp

===============================

Was sind meine Erwartungen an dieses Seminar ???

Was MUSS drin sein

Überblick ...

===============================

== Erzeugungsmuster

== Anti - Pattern

== Übersichtlichkeit des Codes :)

== Erkennen ???

== Wann brauche ich welches Pattern :)

===============================

Frage: Stellt Fragen !!!!!!!!!!!!!!!!!!!

Pause ... um / ab 12.30 

===============================

1. Vorabbemerkung:

== Erkennen ???

== Wann brauche ich welches Pattern :)

== Neue Aufgabe umzusetzen hat // Mindset nachdenken ...

Schwierigste Frage:

a) Man sollte sie kennen / gelernt haben ...

b) Beispiele ...

   i)  Konzeptionelle Beispiel // eine Beschreibung (UML) in Quellcode (C++) umsetzen

   ii) Anwendungs-Beispiel // Real-World Beispiel

===============================================

Single Responsibility Principle <=> God Object

===============================================

Code Smell:  Smell: Geruch // Code riecht // stinkt

================================================

Lösung ist vorhanden

Sind glücklich

Neue Anforderungen !

Frage !!!!!!!!!!!!!!!! : Ist meine aktuelle SW flexibel ??????????????

Flexibilität bedeutet im Regelfall: MEHRERE Klassen // breiteres Spektrum // Zeit // Verständnis 

================================================

a) Ganz enger Weg:  Prototyp // Ziel erreichen // verifizieren.

b) Redesign: Breiten Weg wählst.

================================================

Idiom / Prinzip / Richtlinie / Guide Line

==============================================

Teile der SW entkoppeln !!!!!!!!

Wie: das kann man mit Interfaces erreichen.

===> Losen Kopplung.

==============================================

Adapter Pattern:

Programm: Daten: JSON (Format)

Provider: XML (Format)

==============================================

Function Pointer: Gute Frage

Jepp, ginge:

Tabelle:

switch (format)

{ "avi", fp1 },
{ "mp3", fp2 },
{ "mp4", fp3 },

Etwas zu Prozedural // zu wenig Objekt-orientiert.

Ist ein anderer Ansatz als das Adapter Pattern:

Pro - Contra:   

Wenn die Formate / Inkompatibilitäten WEITER auseinander gehen:

Pattern: Da ist Platz in den Methoden für Umbereitung / Nachbereitung.

Hinweis:  Function Pointer:  Strategy Pattern  versus Function Pointer versus 'std::function'

==============================================

Adapter

Proxy 

==============================================

Was sind die Unterschiede zwischen Adapter Pattern und Proxy Pattern?

== Beide verstecken Klassen hinter dem Rücken des Anwenders

== Proxy leitet nur WEITER.

== Adapter leitet auch WEITER, aber er muss die Anforderung umformulieren (XML nach JSON) ,
     und dann entscheiden, an wen er weiterleitet, wenn mehrere Zielobjekte in Frage kommen.

== Ein Proxy formuliert die Daten NICHT um --- im Gegenteil:

   Er leitet 1:1 weiter / der Client soll davon ja nichts mitbekommen.

== Ein Proxy kann - vor dem eigentlichen Zielaufruf - ergänzende Aktionen tun (Logging. ...)
   bis hin zur Verweigerung des eigentlichen Zielaufrufs.

== Bzgl. des Umfangs der Verdeckung / dessen, was versteckt wird:

a) Proxy: Müsste die ganze Schnittstelle des Zielobjekts umsetzen.

b) Adapter: Legt die vom Client geforderten Methoden offen.

     Im Regelfall sehen wir hier ein oder mehrere Methoden,
     aber nicht das Interface einer gesamten Klasse.


=====================================================

"Einen Proxy für den Adaptee anlegen"

Was ist bei diesem Satz in Hochkomma gemeint:

Damit sollte eigentlich im Proxy eine andere Schnittstelle einhergehen,
eine, die der Client versteht.

Eager vs. Lazy Proxy:

Eager:  eifrig, begierig ==>   direkte Methodenaufruf

Lazy: faul               ==>   kein direkter Methodenaufruf  // on demand , erst wenn es NOTWENDIG ist

=====================================================

Was kann man als "Strategie" auffassen ?? Methode

a) Sortieren:  std::sort ===> Kriterium: aufwärts / abwärts 
                              Personen:  Namen, Alter, Wohnort ...

b) Hierarchie von graf. Klassen:

   Zeichnen:  Windows - Subsystem
              Linux - Subsystem

              Betriebssystem - Spezifika:  ==> Strategy

Strategy - Pattern:

a) Klassisch

b) Modern C++


Funktionszeiger:
================

Einstufung: Okay, sind ein Sprachmittel von C++

==> Sind nicht so wirklich OO

==> Alternativ:  Schnittstellenzeiger // adressiert mehrere Methoden eines Objekts // ==> OO

C++:  std::function

Ist eine universelle Hülle für alles Aufrufbare :)

===========================================

Gilt für viele Pattern:

a) Prinzipiell sind Umsetzungen der Pattern DYNAMISCH ausgelegt / konzipiert.

b) C++ kann das 

c) C++: Generische Sprache : Templates  // Statisch // Übersetzungszeit // Compile-Time.

Geht das auch mit Design Pattern: Statische Umsetzung eines Patterns.

Ja.

Beispiel:

Textformate:

== HTML
== Markdown

Listen: Aufzählung mit Punkt vorne dran.


HTML: 

<ul>
  <li>A</li>
</ul>

Markdown:

  * A


IListStrategy ermöglicht die Erzeugung derartiger Listen in verschiedenen Formaten.

A) Ein Interface beschreibt Methoden für abgeleitete Klassen
   (virtual)  // doppelt indirekt

B) Pendant: Ab C++ 20:  concept / requires

   Ginge auch ohne dieses Pendant -- Punkt B könnte wegfallen.


   'StaticStrategyPatternExample::TextProcessorEx': 
   
   the associated constraints are not satisfied

=====================================================

Template Method Pattern

// VORSICHT: Hat nichts mit Templates von C++ zu tun.

Beispiel:

Spiele

Tetris:

Figuren:  8 Figuren.   Rechteck  // 

Wie bewegt sich eine Figur: 

== Nach unten
== Kann drehen
== Nach links
== Nach rechts
== Ende erreicht, wenn unten kein Platz

Idee:
Irgendwie sollte / könnte man für die Bewegung EINE FUNKTION / Methode
schreiben:

void bewegeTetrimino ()     // Methode: Schablone für alle existierenden Figuren / Bauteile angesehen.
{
    while (true) {
        == Nach unten   // bewegeNachUnten();
        == Kann drehen
        == Nach links
        == Nach rechts
        == Ende erreicht, wenn unten kein Platz //  break;
    }
}

Zentrale Methode: Diese ist NICHT virtuell  !!!

Frage: Wie kann man die Spezifika der 8 verschiedenen Figuren 
da mit rein bringen so dass ich einen Gewinn mit DIESER EINEN Methode habe.

// ============================================================

Unterschied Strategy Pattern // Template Method Pattern

== Beide betrachten eine Methode 

== Die Funktionalität dieser "Methode" (abstract) beim Strategy Pattern
   soll unterschiedlich sein // um unterschiedliche Ausführungen zu erhalten.

== Die Funktionalität dieser "Methode" (Schablonenmethode) beim Template Method Pattern
   gibt es genau EINMAl. Und diese ist NICHT änderbar.


==============================================================

Virtueller Konstruktor
----------------------

Erstelle eine Kopie eines Objekts.

Wo ist das Problem ??? Kopier-Konstruktor.

Erstelle eine Kopie :  Wovon ??? Was habe ich ???

Beispiel:

Spiele-Programmierung:

Spielbrett // Game Board

Figuren // figures

Pseudo-Code:


Figure* board [8][8];

Schachbrett:   

Da stehen auf jeder Zelle andere Figuren .. oder keine ...
aber alle leiten sich von einer Basisklasse "Figure" ab.

Brauche eine echte Kopie des Spielbretts:

Um den / die nächsten Zug / Züge zu berechnen.
Um den "besten" Zug aussuchen zu können.

Langer Rede, kurzer Sinn:

Figure* figur;   // Basisklassenzeiger 

// Kopie:

==> Tower, Queen, Pawn

figur ==> auf die abgeleitete Klasse.

Wie kann ich bei Kenntnis des Basisklassenzeigers eine Kopie des Objekts erstellen,
auf das der Basisklassenzeiger zeigt ???

Java // C#:   

Java:  clone

C#:  ICloneable => clone


Virtueller Konstruktor

        virtual Prototype* clone() const override
        {
            return new ConcretePrototype{ *this };
        }

Ist das ein Widerspruch, das ein Ergebnis des Typs ConcretePrototype zurückgeliefert wird,
und nicht der Typ der Basisklasse in Erscheinung tritt.

Vererbung:  Ist-Ein Beziehung:   Ein ConcretePrototype-Objekt "ist-ein" Prototype-Objekt.


    static void clientCode(Prototype* original)
    {
        Prototype* copy{ original->clone() };


Konkret:

ChessFigure: Abstrakte Basisklasse

Prototype == ChessFigure

class Tower : public ChessFigure

ConcretePrototype == Tower

    static void clientCode(ChessFigure* original)
    {
        ChessFigure* copy = original->clone();  // was soll hier rauskommen: ein Tower 

        // Ein Objekt genau des Typs, der zur LAUFZEIT vorhanden ist:
        // also wenn ein Turm, dann eine Turm-Kopie
        // wenn eine Dame, dann eine Kopie der Dame
    }

    ...
    {
        Tower* t = new Tower();

        clientCode (t);  // reales Objekt  zur RUNTIME
    }

Wann brauch ich so etwas ???

Hmm, wenn ich in Container (Schachbrett) eine Reihe von Basisklassenzeigern habe,
und von diesem Container eine ECHTE Kopie benötige !!!

// Beobachtung: Ähnlichkeiten zu Templates:

Jein:  Templates sind austauschbar ... zur ÜBERSETZUNGSZEIT.

std::vector<int> numbers;

std::vector<double> moreNumbers;

// ========================================================

Wann muss ich den Kopier-Konstruktor selber schreiben:

Wenn Pointer / dyn. Daten / new/ delete / vorhanden sind.
Diese dürfen NICHT 1:1 dupliziert werden ==> Doppeltes delete: NO-Go

Wo keine Pointer: Rule-of-ZERO ==> Der Compiler macht das für uns.

// ========================================================

Factory

Factory-Pattern:  Inflation an derartigen Pattern.

Enge Kopplung:  Exakte Kenntnis der Konstruktor // der Klassen 

Aussage: Muss als Anwender in einem Team nicht detaillierte Kenntniss von "deren" Klassen.

==> Funktionalität von "deren" Klassen haben

Beobachtung: Trennung von einer Reihe von Klassen (Details) und einer Anwendung kann Sinn ergeben.

Auch so rum:

Habe als Anwender den Namen einer Klasse in meinem Quellcode verankert.   Lose  Kopplung .

// ========================================================


Color.FromArgb Methode

A) Fabrik-Gedanke: Wegen der Erzeugungsmethoden   'FromArgb'

Whyyyyyyyyyyyyyyyyyyyyyyy   new Color (100, 0 , 0);

Anderer Grund: Bei vielen gleichen Objekten expldiert meine Speicheranforderung.

==>   'FromArgb' ist etwas versteckt:  Singleton. // gleiche Farben 
                                        werden vom gleichen Objekt beschrieben.